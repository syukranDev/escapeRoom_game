#include "NUC1xx.h"
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include "Driver\DrvSYS.h"
#include "Driver\DrvGPIO.h"
#include "NUC1xx-LB_002\LCD_Driver.h"


#define PPM 4    //how far object move around in pixel 

//seven segment HEX value delcaration
#define SEG_N0   0x82 //0
#define SEG_N1   0xEE //1
#define SEG_N2   0x07 //2
#define SEG_N3   0x46 //3
#define SEG_N4   0x6A  //4
#define SEG_N5   0x52  //5
#define SEG_N6   0x12  //6
#define SEG_N7   0xE6  //7
#define SEG_N8   0x02  //8
#define SEG_N9   0x62  //9

//bmp intro smiley face
unsigned char crosshair[128*8] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0xF8,0xF8,0xF0,0xC0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,0xE0,0xF0,0xF0,0xF0,0xF8,0x78,0x78,0x78,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x78,0xF8,0xF8,0xF0,0xE0,0xC0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFE,0xFE,0xFE,0xF8,0xE0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x1F,0x7F,0xFF,0xFF,0xFF,0xEF,0x8F,0x9E,0x1E,0x3E,0x3C,0x3C,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0xF8,0xF8,0xF8,0xF8,0xF8,0x78,0x7C,0x3E,0x3F,0x1F,0x0F,0x07,0x07,0x07,0x03,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x03,0x07,0x07,0x0F,0x0F,0x1F,0x3E,0x3E,0x7C,0xF8,0xF8,0xF0,0xE0,0xE0,0xC0,0x80,0x80,0x80,0x80,0xC0,0xC0,0xE0,0xF0,0xF8,0xFC,0x7E,0x3F,0x1F,0x0F,0xF3,0xFF,0xFF,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x03,0x07,0x0F,0x1F,0x1F,0x3E,0x3C,0x3C,0x78,0x78,0x78,0xF0,0xF0,0xF0,0xE0,0xE0,0xFC,0xFE,0xFF,0x1F,0x0F,0x07,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xC0,0xC0,0xE0,0xE0,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xE0,0xE0,0xE0,0xE0,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x03,0x07,0x0F,0x0F,0x7F,0xFF,0xFF,0xF3,0xE3,0xC1,0x81,0xC0,0xE0,0xF0,0xFC,0xFF,0x7F,0x1F,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFF,0xFF,0x1F,0x01,0x00,0x00,0x00,0x00,0x00,0xF0,0xF0,0xF0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x03,0x03,0x03,0x03,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x03,0x03,0x03,0x03,0x03,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0xC0,0xC0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0xFF,0x03,0x03,0x03,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xE0,0xE0,0x80,0x00,0x00,0x00,0x00,0x03,0x0F,0x1F,0x1F,0x7E,0xFC,0xFC,0xF0,0xE0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xE0,0xE0,0xE0,0xE0,0xE0,0xF0,0xF0,0xF8,0x7C,0x7E,0x3F,0x1F,0x0F,0x07,0x07,0x07,0x03,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x0F,0x0F,0x0F,0x1E,0x7E,0xFE,0xFC,0xF0,0xE0,0xE0,0xE0,0xC0,0xC0,0x81,0x81,0x01,0x01,0x01,0x01,0x01,0xFF,0xFF,0xFF,0x01,0x01,0x01,0xFF,0xFF,0xFF,0x01,0x01,0x01,0xFF,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,0xE0,0xF0,0xF0,0xFC,0x7F,0x7F,0x1F,0x07,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x03,0x03,0x07,0x07,0x0F,0x0F,0x0F,0x0E,0x0E,0xFE,0xFF,0xFF,0x1F,0x1C,0x1C,0x1C,0x1F,0x1F,0x1F,0x1C,0x1C,0x1C,0x1C,0xFF,0xFF,0xFF,0xFC,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1E,0x1F,0x1F,0x0F,0x07,0x07,0x03,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x3F,0x3F,0x7E,0x78,0x78,0x70,0x70,0x78,0x7C,0x7C,0x3E,0x1F,0x1F,0x0F,0x07,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00


};


void Init_LED()
{
	// initialize GPIO pins
	DrvGPIO_Open(E_GPC, 12, E_IO_OUTPUT); // GPC12 pin set to output mode
	DrvGPIO_Open(E_GPC, 13, E_IO_OUTPUT); // GPC13 pin set to output mode
	DrvGPIO_Open(E_GPC, 14, E_IO_OUTPUT); // GPC14 pin set to output mode
	DrvGPIO_Open(E_GPC, 15, E_IO_OUTPUT); // GPC15 pin set to output mode
	// set GPIO pins to output Low
	DrvGPIO_SetBit(E_GPC, 12); // GPC12 pin output Hi to turn off LED
	DrvGPIO_SetBit(E_GPC, 13); // GPC13 pin output Hi to turn off LED
	DrvGPIO_SetBit(E_GPC, 14); // GPC14 pin output Hi to turn off LED
	DrvGPIO_SetBit(E_GPC, 15); // GPC15 pin output Hi to turn off LED
}

typedef struct position{
		int sca,spa; //start
		int eca,epa; //end
	}position;
typedef enum{
	forward = 1,
	downward = 2,
	left = 3,
	right = 4
}direction; 
int move_h=0,move_v=0,sec=0,min=0;
uint8_t map_num=0,dir=2;
position ini_dir[4],now_dir[4];
position object[4];

void PWM4_Init(void){
	PWMB->CSR.CSR0 = 4; // Divider
	PWMB->PPR.CP01 = 1; // prescaler
	
	PWMB->PCR.CH0MOD = 1; // Auto-reload Mode.
	
	PWMB->CMR0 = 1;  // PWM Group A/B Comparator Register 
	PWMB->CNR0 = 3;  // PWM Group A/B Counter Register 
	
	PWMB->POE.PWM0 = 1;  // PWM0: PWM output
	PWMB->PCR.CH0EN = 1;  // PWM Timer Starting.
}

void PWM_Freq(unsigned int freq, unsigned char duty_cycle){
	static unsigned short M, N;
	
	if(freq==0){
		M=0;
		N=0;
	}else{
		N = 50000000/2/freq; 
		M = duty_cycle*N/100;  
	}
	PWMB->CMR0 = M;
	PWMB->CNR0 = N;
}

// continuous move
void TIMER1_Init(void){
	SYSCLK->CLKSEL1.TMR1_S = 2 ; 
	SYSCLK->APBCLK.TMR1_EN =1 ;	
	
	NVIC_EnableIRQ(TMR1_IRQn);	
	
	TIMER1->TCSR.MODE = 1;
	
	TIMER1->TCSR.PRESCALE = 99;
	
	TIMER1->TCSR.TDR_EN =1;
	
	TIMER1->TCSR.CTB =0;
	
	TIMER1->TCSR.IE =0;	
	
	TIMER1->TCMPR = 400000; 
	
	TIMER1->TCSR.CEN =0;
	
	TIMER1->TCSR.CRST =0;	
}
// clock
void TIMER2_Init(void){
	SYSCLK->CLKSEL1.TMR2_S = 2 ; 
	SYSCLK->APBCLK.TMR2_EN =1 ;	
	
	NVIC_EnableIRQ(TMR2_IRQn);	
	
	TIMER2->TCSR.MODE = 1;
	
	TIMER2->TCSR.PRESCALE = 0;
	
	TIMER2->TCSR.TDR_EN =1;
	
	TIMER2->TCSR.CTB =0;
	
	TIMER2->TCSR.IE =1;	
	
	TIMER2->TCMPR = 50000;
	
	TIMER2->TCSR.CEN =1;
	
	TIMER2->TCSR.CRST =0;	
}
void SYS_Delay(unsigned int us){
		static unsigned char repeat;
	
	  repeat = 25;

			SysTick->CTRL &= ~( 1 | 1 << 16 ); 
			SysTick->LOAD = us;
			SysTick->VAL  = 0;
			SysTick->CTRL = SysTick_CTRL_ENABLE_Msk;
		while(repeat--){
			while((SysTick->CTRL & (1 << 16)) == 0);
			SysTick->VAL  = 0;
		}
}

void OpenKey_Pad(void){
	uint8_t i;
	for(i=0;i<6;i++)
	DrvGPIO_Open(E_GPA, i, E_IO_QUASI);
}
void GPC_set(unsigned int pin){
	volatile unsigned int *reg_ptr; 
  reg_ptr = (unsigned int *)(0x50004000 + 0x8C);
  *reg_ptr = (unsigned int)(0xf<<12);
  reg_ptr = (unsigned int *)(0x50004000 + 0x88);
  *reg_ptr = (unsigned int)(1<<pin);
}
void Show_seven_segment(unsigned char place, unsigned char number){
  unsigned char temp,i;
	unsigned char SEG_BUF[]={SEG_N0, SEG_N1, SEG_N2, SEG_N3, SEG_N4, SEG_N5, SEG_N6, SEG_N7, SEG_N8, SEG_N9};
	temp=SEG_BUF[number];
	
	for(i=0;i<8;i++)
	{
		if((temp&0x01)==0x01)
		{			
		   DrvGPIO_SetBit(E_GPE,i);
		}else{
		   DrvGPIO_ClrBit(E_GPE,i);		
		}			
		   temp=temp>>1;
		GPC_set(4+place);	
	}
}

uint8_t Scan_key(void){	
	uint8_t act[3]={0x3,0x5,0x6}; 
	uint8_t i,temp,pin;
	volatile unsigned int * ptrPin;
	ptrPin = (unsigned int *) (0x50004000 + 0x10);
	
	for(i=0;i<3;i++)
	{
		temp=act[i];
		for(pin=0;pin<3;pin++)
		{
			if((temp&0x01)==0x01)  
			{
				DrvGPIO_SetBit(E_GPA,pin); 
			}else{
				DrvGPIO_ClrBit(E_GPA,pin); 
			}
			temp>>=1;
		}	
		if (((*ptrPin >>3 )& 0x1) == 0 && i == 1)  
			return forward;  
		if (((*ptrPin >>4 )& 0x1) == 0 && i == 1) 
			return downward;  
		if (((*ptrPin >>4 )& 0x1) == 0 && i == 0) 
			return left; 	
	  if (((*ptrPin >>4 )& 0x1) == 0 && i == 2) 
			return right;	
	}
		return 0;
}

void Start_game(void){
	print_lcd(0,"   Escape Room ");
	print_lcd(1,"    Goodluck!");
  print_lcd(2,"----------------------");
	print_lcd(3,"    RTMS 2020");
}
void Stage_clear(void){
	int i=0,j=0;
	clr_all_panel();
	print_lcd(1,"  You are free! :D");
	print_lcd(2,"  Github  ");
	print_lcd(3,"  Syukran.Dev  ");
	TIMER0->TCSR.IE=0;
	TIMER1->TCSR.IE=0;
	TIMER2->TCSR.IE=0;
	
  while(1){
		Show_seven_segment(3,min/10);
		SYS_Delay(1000);
		Show_seven_segment(2,min%10);
		SYS_Delay(1000);
		Show_seven_segment(1,sec/10);
		SYS_Delay(1000);
		Show_seven_segment(0,sec%10);
		SYS_Delay(1000);
		i++;
		if(i>=20){
			PWM_Freq(stage_clear[j],75);
			j++;
			i=0;
			if(j>=78) PWMB->PCR.CH0EN = 0;
		}
	}
}
/////////////////////////////////////////////////padam object when move to different areas of the stage
void Erase_object(void){
	int i,j;
	for(i=object[map_num].sca;i<=object[map_num].eca;i++)
		for(j=object[map_num].spa;j<=object[map_num].epa;j++)
			map[map_num][i][j/8] &= ~(0x80 >> (j%8));		
}

/////////////////////////////////////////////detect object and draw boundaries (got bug here sometimes cant move if object near the wall) 
bool Detect_object(void){	
	int i,j;
	static char pkey=0;	
	
	for(i = now_dir[dir-1].sca ; i <= now_dir[dir-1].eca; i++){ 
		
		if(i<0 && (map_num==2 || map_num==3)) return true;
		else if(i>127 && (map_num == 0 || map_num == 1)) return true;
		else if(i<0 ||i >127) return false;
		
		for(j = now_dir[dir-1].spa ; j <= now_dir[dir-1].epa; j++){ 
			
			if(j<0 && (map_num == 1 || map_num == 3)) return true;
		  else if(j>63 && (map_num == 0 || map_num == 2)) return true;
			else if(j>63 && i>=56 && i<=79 && map_num == 3) {Stage_clear();return true;}
		  else if(j<0 || j >63) return false;	
      
      if(map_num < 2){
			  if(i >= object[map_num].sca && i <= object[map_num].eca && j >= object[map_num].spa && j <= object[map_num].epa){
			    Erase_object();
				  pkey++;
				  return true;
			  }
			}
      else{
				if(i >= object[map_num].sca && i <= object[map_num].eca && j >= object[map_num].spa && j <= object[map_num].epa && pkey>0){
			    Erase_object();
					pkey--;
				  return true;
			  }
			}
			
			if((map[map_num][i][j/8] >> (7-j%8)) & 0x01)
		    return false;
		}
	} 
	return true;
}
void Update_dir(void){
	int i;
	int speedv = PPM * move_v;
	int speedh = PPM * move_h;
	
	if(speedv>=46) speedv-=46;
	if(speedh>=110) speedh-=110;
	for(i=0;i<=3;i++){
		now_dir[i].sca = ini_dir[i].sca + speedh;
		now_dir[i].eca = ini_dir[i].eca + speedh;
		now_dir[i].spa = ini_dir[i].spa + speedv;
		now_dir[i].epa = ini_dir[i].epa + speedv;
	}
}
void Player_move(void){
	if(Detect_object()){
	  switch(dir){
		  case forward : move_v++; break;
		  case downward: move_v--; break;
		  case left  : move_h--; break;
		  case right : move_h++; break;
	  }
		Update_dir();
	}	
}
///////////////////////////////////////////pose bila tekan keypad
uint8_t Select_pose(void){
	switch(dir){
		case forward : return 0;
		case downward : return 0; 
		case left : return 0; 
		case right : return 0;
		default : return 0;
	}
}

uint8_t Select_map(int *speedv,int *speedh){
	if(*speedv <= 44 && *speedh <= 108) return 0;
	else if(*speedv > 44 && *speedh <= 108){
		*speedv-=46;
		return 1;
	}
	else if(*speedv <= 44 && *speedh > 108){
	  *speedh-=110;
		return 2;
	}
	else{
	  *speedv-=46;
	  *speedh-=110;
		return 3;
	} 
}

//////////////////////////draw 4 different area of the stages
void Show_LCD(void){
	int pa,ca,i=14,j=15;
	int speedv = PPM * move_v;
	int speedh = PPM * move_h;
	uint8_t data=0,pose_num;
	
	clr_all_panel();	
	map_num = Select_map(&speedv,&speedh);
	pose_num = Select_pose();
	
	for(ca=2;ca<=129;ca++)
		for(pa=0;pa<=63;pa++){
			if( (ca>=113-speedh && ca<=127-speedh) && (pa >= 46-speedv &&  pa<=61-speedv) ){
			  if((map[map_num][129-ca][7-pa/8]>>(pa%8))&0x1 || player[pose_num][i][j])
					data |= (0x01 << (pa % 8));				  
				j--;
				if(j== -1){
			    j=15; i--;
				}		  
			}	
			else if((map[map_num][129-ca][7-pa/8]>>(pa%8))&0x1)
				data |= (0x01 << (pa % 8));		
			if(pa % 8 == 7){
				  SetPACA(pa/8,ca);
					WriteData(data);
					data = 0;
			}
		}
} 

void TMR0_IRQHandler(void){
	static int i=0;
		PWM_Freq(gourmet[i],75);
		i++;
		if(i >= 272) TIMER0->TCMPR = 2016129;
		if(i>783){ i=0; TIMER0->TCMPR = 8064516;}
		TIMER0->TISR.TIF =1;
	/*else{
		PWM_Freq(stage_clear[j],75);
		j++;
		if(j>=78) PWMB->PCR.CH0EN = 0;  // PWM Timer Stop.
		TIMER0->TISR.TIF =1;
	} */
} 

void TMR1_IRQHandler(void){
	TIMER1->TCMPR = 50000;
	Player_move();
	Show_LCD();
	TIMER1->TISR.TIF =1 ;
} 
void TMR2_IRQHandler(void){
	static char i = 0;
	static int j = 0;

	switch(i){
		case 0: Show_seven_segment(i,sec%10); break;
	  case 1: Show_seven_segment(i,sec/10); break;
		case 2: Show_seven_segment(i,min%10); break;
		case 3: Show_seven_segment(i,min/10); 
	}
	i++; j++;
	if(i>3) i = 0;
	if(j == 1000){
		sec++;
		if(sec == 60){
			sec = 0; min++;
		}
		j=0;
	}
	TIMER2->TISR.TIF =1 ; 
} 
void Initialization(void){
	Initial_panel();
	clr_all_panel();
  OpenKey_Pad();
	PWM4_Init();
	//TIMER0_Init();
	TIMER1_Init();
	TIMER2_Init();
	ini_dir[0].sca=1  ;ini_dir[0].spa=18 ;ini_dir[0].eca=17     ;ini_dir[0].epa=18+PPM; 
	ini_dir[1].sca=1  ;ini_dir[1].spa=-1 ;ini_dir[1].eca=17     ;ini_dir[1].epa=-1+PPM;
	ini_dir[2].sca=-1 ;ini_dir[2].spa=1  ;ini_dir[2].eca=-1+PPM ;ini_dir[2].epa=18;
	ini_dir[3].sca=17 ;ini_dir[3].spa=1  ;ini_dir[3].eca=17+PPM ;ini_dir[3].epa=18;
	Update_dir();
	object[0].sca=89;object[0].spa=11;object[0].eca=93;object[0].epa=19;
	object[1].sca=68;object[1].spa=45;object[1].eca=72;object[1].epa=53;
	object[2].sca=72;object[2].spa=40;object[2].eca=82;object[2].epa=56;
	object[3].sca=63;object[3].spa=48;object[3].eca=73;object[3].epa=63;
}

void delay_loop(void)
{
uint32_t i,j;
for(i=0;i<3;i++)
{
for(j=0;j<60000;j++);
 }
}

int main(void){
	UNLOCKREG();
	DrvSYS_Open(50000000);// set System Clock to run at 50MHz.
	SYSCLK->CLKSEL0.STCLK_S = 0x3; 
	SYSCLK->CLKSEL2.PWM45_S = 2;   // PWM clock source
	SYSCLK->APBCLK.PWM45_EN = 1; 
	SYS->ALTMFP.PB11_PWM4 = 1; 
	SYS->GPBMFP.TM3_PWM4 = 1; 
	LOCKREG(); 
	///
	///
	
	Init_LED(); 
 
	DrvGPIO_ClrBit(E_GPC, 12); 
	DrvGPIO_ClrBit(E_GPC, 13);
	DrvGPIO_ClrBit(E_GPC, 14); 
	DrvGPIO_ClrBit(E_GPC, 15); 
	//draw_LCD(crosshair);
	DrvSYS_Delay(300000);	     // delay 
	DrvGPIO_SetBit(E_GPC, 12); 
	DrvGPIO_SetBit(E_GPC, 13); 
	DrvGPIO_SetBit(E_GPC, 14); 
	DrvGPIO_SetBit(E_GPC, 15); 
	DrvSYS_Delay(300000);
	DrvGPIO_ClrBit(E_GPC, 12); 
	DrvGPIO_ClrBit(E_GPC, 13);
	DrvGPIO_ClrBit(E_GPC, 14); 
	DrvGPIO_ClrBit(E_GPC, 15); 
	//draw_LCD(crosshair);
	DrvSYS_Delay(300000);	     // delay 
	DrvGPIO_SetBit(E_GPC, 12); 
	DrvGPIO_SetBit(E_GPC, 13); 
	DrvGPIO_SetBit(E_GPC, 14); 
	DrvGPIO_SetBit(E_GPC, 15); 
	DrvSYS_Delay(300000);
	DrvGPIO_ClrBit(E_GPC, 12); 
	DrvGPIO_ClrBit(E_GPC, 13);
	DrvGPIO_ClrBit(E_GPC, 14); 
	DrvGPIO_ClrBit(E_GPC, 15); 
	//draw_LCD(crosshair);
	DrvSYS_Delay(300000);	     // delay 
	DrvGPIO_SetBit(E_GPC, 12); 
	DrvGPIO_SetBit(E_GPC, 13); 
	DrvGPIO_SetBit(E_GPC, 14); 
	DrvGPIO_SetBit(E_GPC, 15); 
	DrvSYS_Delay(300000);
	 
	//
	//
	Initialization();
	
	draw_LCD(crosshair);
	DrvSYS_Delay(3000000);
	
	Start_game();
	clr_all_panel();
	Start_game();
	
  while(Scan_key() == 0);
	dir = 2;
	Show_LCD();
	while(1){	
    dir = Scan_key();
		if(dir != 0){
			Player_move();
			Show_LCD();
	    SYS_Delay(60000);
		  do{
			  dir = Scan_key();
		  }while(dir != 0);
		  SYS_Delay(60000);
	  }	
	} 
}
